#!/usr/bin/env python
from nsuolymp import *
import argparse

# handle cmd arguments
parser = argparse.ArgumentParser(description = "Runs one or many solutions on current tests.")
parser.add_argument('solutions', help = "one or several solutions: either executables or source files (* or @ means 'all solutions')", nargs = '+')
parser.add_argument('-q', '--quiet', help = "print only results (no intermediate messages)", action = "store_true")
parser.add_argument('-e', '--stop-on-error', help = "stop script after first error encountered", action = "store_true")
parser.add_argument('-c', '--compile', help = "force compilation of solutions and checker from sources", action = "store_true")
parser.add_argument('-g', '--gen-output', help = "overwrite test output files with answers generated by solution", action = "store_true")
parser.add_argument('-s', '--stress', help = "stress test solutions; generator with arguments must be specified just afterwards in double quotes", metavar = "GEN")
parser.add_argument('-t', '--tl', help = "specify time limit in seconds (by default taken from problem statement, 0 means 'no limit')", type = float)
parser.add_argument('-m', '--ml', help = "specify memory limit in seconds (by default taken from problem statement, 0 means 'no limit')", type = float)
parser.add_argument('-i', '--tests', help = "comma-separated list of test names to run on (by default all tests are used)", metavar = "TESTS")
args = parser.parse_args()

test_all_solutions = ('*' in args.solutions or '@' in args.solutions)
if args.gen_output:
	if args.stress:
		print("Option --stress is incompatible with --gen-output")
		raise SystemExit
	if test_all_solutions or len(args.solutions) != 1:
		print("Exactly one solution must be specified with --gen-output")
		raise SystemExit

cfg = Config(quiet = args.quiet, stop = args.stop_on_error)
# resolve limits
if args.tl is None or args.ml is None:
	problem_limits = read_limits(find_problem_statement())
	if problem_limits is not None:
		if args.tl is None:
			args.tl = convert_default_time_limit(problem_limits[0])
		if args.ml is None:
			args.ml = problem_limits[1]
if args.tl > 0.0:
	cfg.tl = args.tl
if args.ml > 0.0:
	cfg.ml = args.ml

compile_results = test_results = stress_results = None

class StopError(Exception):
	pass
try:
	# find out what should we compile
	compile_list = []

	if args.compile or not if_exe_exists('check'):
		compile_list.extend(get_sources_in_problem(checker = True))
	if args.compile and args.stress:
		compile_list.extend(get_sources_in_problem(validator = True))

	if test_all_solutions:
		# compile all solution sources
		if args.compile:
			compile_list.extend(get_sources_in_problem(solutions = True))
	else:
		for sol in args.solutions:
			sol_noext = path.splitext(sol)[0]
			# compile specified solution
			if args.compile:
				if is_source(sol):
					compile_list.append(sol)
				else:
					related_files = [sol] + glob.glob(sol_noext + '.*')
					related_sources = filter(is_source, related_files)
					compile_list.extend(related_sources)
			else:
				if is_source(sol) and not has_java_task(sol):
					compile_list.append(sol)

	# compile all the necessary sources
	compile_results = compile_sources(compile_list, cfg)
	if cfg.stop and len(compile_results[1]) > 0:
		raise StopError()

	# find out solutions we have to test
	solutions_list = []
	
	if test_all_solutions:
		solutions_list = get_solutions()
	else:
		for sol in args.solutions:
			sol_noext = path.splitext(sol)[0]
			if is_solution(sol_noext):
				solutions_list.append(sol_noext)
			else:	
				printq(cfg.quiet, colored_verdict('W', "Solution %s does not exist" % sol_noext))
				if cfg.stop:
					raise StopError()

	# find out subset of tests to run on (if any)
	tests_list = None
	if args.tests:
		tests_list = re.split(r'\,|\.|\s', args.tests)
		tests_list = [get_test_input(t) for t in tests_list]

	# test all solutions
	if args.stress:
		generator = args.stress.split()
		for seed in stress_test_solutions(cfg, generator, solutions_list):
			stress_results = seed
			break
	elif args.gen_output:
		solution = solutions_list[0]
		test_results = [(solution, check_solution(cfg, solution, tests_list, True))]
	else:
		test_results = check_many_solutions(cfg, solutions_list, tests_list)
except (StopError):
	pass

if compile_results is not None:
	print_compile_results(compile_results)
if test_results is not None:
	print_solutions_results(test_results)
if stress_results is not None:
	print(colored_verdict('W', "Stopped on a problematic test generated with seed = " + str(stress_results)))
