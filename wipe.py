#!/usr/bin/env python
from nsuolymp import *
import argparse, sys, os, shutil, glob
from os import path

def deduplicate(arr):
    # type: (List[str]) -> List[str]
    res = []    # type: List[str]
    for f in arr:
        if f not in res:
            res.append(f)
    return res

def report_deleted(arr, name):
    # type: (List[str], str) -> None
    if len(arr) == 0:
        return
    print(color_highlight("Found %d %s:" % (len(arr), name)))
    adj = max([len(f) for f in arr])
    adj = max(adj, 20)
    G = 1
    if len(arr) > 20:
        G = 2
    if len(arr) > 40:
        G = 3
    if len(arr) > 60:
        G = 4
    if len(arr) > 100:
        G = 5
    groups = [arr[i:i + G] for i in range(0, len(arr), G)]
    for group in groups:
        while len(group) < G:
            group.append("")
        print("  " + "  ".join([f.ljust(adj) for f in group]))

def main(argv = None):
    # type: (Optional[List[str]]) -> int
    # handle cmd arguments
    parser = argparse.ArgumentParser(description = "Deletes various intermediate files.")
    parser.add_argument('-i', '--interm', help = "delete intermediate files, e.g.: input.txt, answer.txt, stress_test", action = "store_true")
    parser.add_argument('-c', '--compile', help = "delete compile/build artefacts, e.g.: executables, objects, class-es", action = "store_true")
    parser.add_argument('-g', '--generate', help = "delete tests generated by specified script", nargs = '?', const = "gen.cmd")
    parser.add_argument('-o', '--output', help = "delete output files for all tests", action = "store_true")
    parser.add_argument('-a', '--all', help = "delete almost everything (implies -i, -c, -g)", action = "store_true")
    parser.add_argument('-q', '--quiet', help = "don't ask confirmation, don't print intermediate messages", action = "store_true")
    args = parser.parse_args(argv)

    if args.all:
        args.interm = args.compile = True
        if args.generate is None:
            args.generate = "gen.cmd"

    all_files = []  # type: List[str]
    all_dirs = []   # type: List[str]

    if args.compile:
        all_files += glob.glob('*.exe')
        all_files += glob.glob('*.obj')
        all_files += glob.glob('*.o')
        all_files += glob.glob('*.class')
        all_files += glob.glob('*.jar')
        if path.isdir('__pycache__'):
            all_dirs.append('__pycache__')
        # This fits two purposes:
        #  1) Detect java/Task solutions
        #  2) Find executables on Linux
        src_files = get_sources_in_problem(validator = True, checker = True, solutions = True, generators = True)
        for src in src_files:
            name = path.splitext(src)[0]
            if path.isfile(name):
                all_files.append(name)
            if has_java_task(name):
                all_files += glob.glob(path.join(name, '*.class'));

    if args.interm:
        all_files.append('input.txt')
        all_files.append('output.txt')
        all_files.append('answer.txt')
        all_files.append('_stdout_')
        all_files.append('_stderr_')
        all_files += glob.glob('stress_test.*')
        all_files += list(read_filenames())

    if args.output:
        all_files += list(map(get_output_by_input, get_tests_inputs()))

    if args.generate:
        gen_script = parse_generation_script(args.generate)
        if isinstance(gen_script, str):
            print_parse_generation_script(gen_script)
        else:
            for line in gen_script[0]:
                test = get_test_input(line.test)
                all_files.append(test)
                all_files.append(get_output_by_input(test))

    all_files = list(filter(path.isfile, deduplicate(all_files)))
    all_dirs = list(filter(path.isdir, deduplicate(all_dirs)))

    if len(all_files) == 0 and len(all_dirs) == 0:
        print(colored_verdict('D', "No files found to be removed (run with --help to see help)"))
        return 0

    if not args.quiet:
        report_deleted(all_files, "files")
        report_deleted(all_dirs, "directories")
        print(colored_verdict('R', "Do you really want to delete all these files? (y/n)"))
        yesno = input().lower()
        if yesno not in ['y', 'yes']:
            print(colored_verdict('W', "Wipe cancelled"))
            return 1

    for f in all_files:
        removefile(f)
    for f in all_dirs:
        shutil.rmtree(f)

    print(colored_verdict('A', "%d files and %d directories removed" % (len(all_files), len(all_dirs))))
    return 0

if __name__ == "__main__":
    sys.exit(main())
